{
  "name": "THub V2 - Batch Analysis with Priority (FIXED)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "batch-analysis-trigger",
        "responseMode": "onReceived",
        "responseData": "firstEntryJson",
        "options": {
          "noResponseBody": false
        }
      },
      "id": "webhook-trigger",
      "name": "Batch Analysis Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [250, 300],
      "webhookId": "batch-analysis-trigger",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "try {\n  // Extract symbols and scores from webhook trigger\n  const input = $input.first();\n  const data = input ? input.json : {};\n  \n  console.log('Webhook data received:', JSON.stringify(data, null, 2));\n  \n  const symbols = data.symbols || [];\n  const scores = data.metadata?.opportunityScores || [];\n  const priority = data.priority || 'normal';\n  const source = data.metadata?.source || 'manual';\n\n  if (symbols.length === 0) {\n    console.warn('No symbols received for analysis');\n    return [{\n      json: {\n        error: 'No symbols provided',\n        batches: [],\n        summary: { totalSymbols: 0, batchCount: 0 }\n      }\n    }];\n  }\n\n  console.log(`Processing ${symbols.length} symbols from ${source}`);\n\n  // Create priority queue with safety checks\n  const priorityQueue = symbols.map((symbol, index) => {\n    const scoreData = scores.find(s => s && s.symbol === symbol) || {};\n    return {\n      symbol: symbol,\n      opportunityScore: scoreData.score || 50,\n      priority: priority,\n      source: source,\n      index: index\n    };\n  }).filter(item => item.symbol); // Remove any null/undefined symbols\n\n  // Sort by opportunity score (highest first)\n  priorityQueue.sort((a, b) => (b.opportunityScore || 0) - (a.opportunityScore || 0));\n\n  // Split into batches for parallel processing\n  const batchSize = Math.min(10, Math.max(1, Math.ceil(priorityQueue.length / 5))); // Dynamic batch size\n  const batches = [];\n  \n  for (let i = 0; i < priorityQueue.length; i += batchSize) {\n    const batchSymbols = priorityQueue.slice(i, i + batchSize);\n    batches.push({\n      batchNumber: Math.floor(i / batchSize) + 1,\n      symbols: batchSymbols,\n      totalSymbols: batchSymbols.length,\n      avgScore: batchSymbols.reduce((sum, s) => sum + (s.opportunityScore || 0), 0) / batchSymbols.length\n    });\n  }\n\n  console.log(`Created ${batches.length} batches with sizes:`, batches.map(b => b.totalSymbols));\n\n  return batches.map(batch => ({ json: batch }));\n  \n} catch (error) {\n  console.error('Error preparing batches:', error.message);\n  \n  return [{\n    json: {\n      error: error.message,\n      batches: [],\n      summary: { \n        totalSymbols: 0, \n        batchCount: 0,\n        errorDetails: error.stack\n      }\n    }\n  }];\n}"
      },
      "id": "prepare-batches",
      "name": "Prepare Priority Batches",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "split-batches",
      "name": "Split Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [650, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://www.thub.rajanmaher.com/api/webhooks/n8n",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "contentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "action",
              "value": "batch_analyze"
            },
            {
              "name": "symbols",
              "value": "={{ $json.symbols ? $json.symbols.map(s => s.symbol) : [] }}"
            },
            {
              "name": "priority",
              "value": "high"
            },
            {
              "name": "metadata",
              "value": "={{ { batchNumber: $json.batchNumber, source: 'batch_processor', scores: $json.symbols, totalBatches: $workflow.batchesTotal || 1, avgScore: $json.avgScore } }}"
            }
          ]
        },
        "options": {
          "timeout": 120000,
          "retry": {
            "enabled": true,
            "maxAttempts": 2\n          }\n        }\n      },\n      \"id\": \"analyze-batch\",\n      \"name\": \"Analyze Batch\",\n      \"type\": \"n8n-nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [850, 300],\n      \"credentials\": {\n        \"httpHeaderAuth\": {\n          \"id\": \"n8n-webhook-auth\",\n          \"name\": \"n8n Webhook Auth\"\n        }\n      },\n      \"onError\": \"continueErrorOutput\"\n    },\n    {\n      \"parameters\": {\n        \"language\": \"javaScript\",\n        \"jsCode\": \"try {\\n  // Aggregate results from all batches\\n  const allInputs = $input.all();\\n  const allResults = [];\\n  let totalProcessed = 0;\\n  let totalErrors = 0;\\n\\n  console.log(`Aggregating results from ${allInputs.length} batch responses`);\\n\\n  for (const item of allInputs) {\\n    try {\\n      const itemData = item.json;\\n      \\n      if (itemData.results && Array.isArray(itemData.results)) {\\n        allResults.push(...itemData.results);\\n        totalProcessed += itemData.results.length;\\n      } else if (itemData.error) {\\n        console.error('Batch error:', itemData.error);\\n        totalErrors++;\\n      }\\n    } catch (error) {\\n      console.error('Error processing batch item:', error.message);\\n      totalErrors++;\\n    }\\n  }\\n\\n  console.log(`Processed ${totalProcessed} results with ${totalErrors} errors`);\\n\\n  // Calculate comprehensive summary statistics\\n  const validResults = allResults.filter(r => r && typeof r === 'object');\\n  \\n  const summary = {\\n    totalSymbols: validResults.length,\\n    signalsCreated: validResults.filter(r => r.signalCreated === true).length,\\n    averageScore: validResults.length > 0 ? \\n      validResults.reduce((sum, r) => sum + (r.convergenceScore || 0), 0) / validResults.length : 0,\\n    strongSignals: validResults.filter(r => r.signalStrength === 'STRONG').length,\\n    mediumSignals: validResults.filter(r => r.signalStrength === 'MEDIUM').length,\\n    weakSignals: validResults.filter(r => r.signalStrength === 'WEAK').length,\\n    errorCount: totalErrors,\\n    timestamp: new Date().toISOString(),\\n    batchCount: allInputs.length\\n  };\\n\\n  // Get high-value signals (score >= 70)\\n  const highValueSignals = validResults\\n    .filter(r => r.signalCreated && (r.convergenceScore || 0) >= 70)\\n    .sort((a, b) => (b.convergenceScore || 0) - (a.convergenceScore || 0))\\n    .slice(0, 10); // Top 10 signals\\n\\n  // Success rate calculation\\n  const successRate = summary.totalSymbols > 0 ? \\n    (summary.signalsCreated / summary.totalSymbols * 100).toFixed(1) : 0;\\n\\n  console.log(`Batch analysis complete: ${summary.signalsCreated} signals from ${summary.totalSymbols} symbols (${successRate}% success rate)`);\\n\\n  return [{\\n    json: {\\n      summary: summary,\\n      highValueSignals: highValueSignals,\\n      allResults: validResults,\\n      metadata: {\\n        successRate: parseFloat(successRate),\\n        avgScoreByStrength: {\\n          strong: summary.strongSignals > 0 ? \\n            validResults.filter(r => r.signalStrength === 'STRONG')\\n              .reduce((sum, r) => sum + (r.convergenceScore || 0), 0) / summary.strongSignals : 0,\\n          medium: summary.mediumSignals > 0 ? \\n            validResults.filter(r => r.signalStrength === 'MEDIUM')\\n              .reduce((sum, r) => sum + (r.convergenceScore || 0), 0) / summary.mediumSignals : 0\\n        },\\n        processing: {\\n          batchesProcessed: allInputs.length,\\n          totalErrors: totalErrors,\\n          processingTime: Date.now()\\n        }\\n      }\\n    }\\n  }];\\n  \\n} catch (error) {\\n  console.error('Error aggregating results:', error.message);\\n  \\n  return [{\\n    json: {\\n      summary: {\\n        totalSymbols: 0,\\n        signalsCreated: 0,\\n        averageScore: 0,\\n        strongSignals: 0,\\n        mediumSignals: 0,\\n        weakSignals: 0,\\n        errorCount: 1,\\n        timestamp: new Date().toISOString()\\n      },\\n      highValueSignals: [],\\n      allResults: [],\\n      error: error.message,\\n      errorStack: error.stack\\n    }\\n  }];\\n}\"\n      },\n      \"id\": \"aggregate-results\",\n      \"name\": \"Aggregate Results\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [1050, 300],\n      \"onError\": \"continueRegularOutput\"\n    },\n    {\n      \"parameters\": {\n        \"conditions\": {\n          \"options\": {\n            \"caseSensitive\": true,\n            \"leftValue\": \"\",\n            \"typeValidation\": \"strict\"\n          },\n          \"conditions\": [\n            {\n              \"id\": \"signals-created\",\n              \"leftValue\": \"={{ $json.summary ? $json.summary.signalsCreated : 0 }}\",\n              \"rightValue\": \"0\",\n              \"operator\": {\n                \"type\": \"number\",\n                \"operation\": \"gt\"\n              }\n            }\n          ]\n        }\n      },\n      \"id\": \"check-signals\",\n      \"name\": \"Signals Created?\",\n      \"type\": \"n8n-nodes-base.if\",\n      \"typeVersion\": 2.2,\n      \"position\": [1250, 300],\n      \"onError\": \"continueRegularOutput\"\n    },\n    {\n      \"parameters\": {\n        \"language\": \"javaScript\",\n        \"jsCode\": \"try {\\n  // Format signal alerts for Slack notification\\n  const input = $input.first();\\n  const data = input ? input.json : {};\\n  \\n  const signals = data.highValueSignals || [];\\n  const summary = data.summary || {};\\n  const metadata = data.metadata || {};\\n\\n  console.log(`Formatting alerts for ${signals.length} high-value signals`);\\n\\n  // Create alert messages for top signals\\n  const alerts = signals.slice(0, 5).map((signal, index) => {\\n    const score = signal.convergenceScore || 0;\\n    const strength = signal.signalStrength || 'UNKNOWN';\\n    const symbol = signal.symbol || 'N/A';\\n    \\n    return {\\n      symbol: symbol,\\n      score: score,\\n      strength: strength,\\n      message: `${index + 1}. ${symbol}: Score ${score.toFixed(1)} (${strength})`,\\n      emoji: strength === 'STRONG' ? '🔥' : strength === 'MEDIUM' ? '⚡' : '📈'\\n    };\\n  });\\n\\n  // Create comprehensive summary message\\n  const successRate = metadata.successRate || 0;\\n  const processingTime = metadata.processing ? \\n    `Processing: ${metadata.processing.batchesProcessed} batches` : 'Processing complete';\\n\\n  const summaryMessage = [\\n    `📊 *Batch Analysis Complete*`,\\n    `• Analyzed: ${summary.totalSymbols || 0} symbols`,\\n    `• Signals Created: ${summary.signalsCreated || 0} (${successRate}%)`,\\n    `• Strong: ${summary.strongSignals || 0} | Medium: ${summary.mediumSignals || 0}`,\\n    `• Average Score: ${(summary.averageScore || 0).toFixed(1)}`,\\n    `• ${processingTime}`\\n  ].join('\\\\n');\\n\\n  // Determine if we have exceptionally high-value signals (score >= 80)\\n  const hasExceptionalSignals = signals.some(s => (s.convergenceScore || 0) >= 80);\\n  const alertColor = hasExceptionalSignals ? '#ff0000' : summary.signalsCreated > 5 ? '#ffaa00' : '#00ff00';\\n\\n  console.log(`Alert prepared: ${alerts.length} signals, exceptional: ${hasExceptionalSignals}`);\\n\\n  return [{\\n    json: {\\n      alerts: alerts,\\n      summaryMessage: summaryMessage,\\n      hasHighValue: signals.length > 0,\\n      hasExceptionalValue: hasExceptionalSignals,\\n      alertColor: alertColor,\\n      metadata: {\\n        topScore: signals.length > 0 ? signals[0].convergenceScore : 0,\\n        signalCount: signals.length,\\n        successRate: successRate\\n      }\\n    }\\n  }];\\n  \\n} catch (error) {\\n  console.error('Error formatting alerts:', error.message);\\n  \\n  return [{\\n    json: {\\n      alerts: [],\\n      summaryMessage: `❌ Error formatting alerts: ${error.message}`,\\n      hasHighValue: false,\\n      hasExceptionalValue: false,\\n      alertColor: '#ff0000',\\n      error: error.message\\n    }\\n  }];\\n}\"\n      },\n      \"id\": \"format-alerts\",\n      \"name\": \"Format Alerts\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [1450, 200],\n      \"onError\": \"continueRegularOutput\"\n    },\n    {\n      \"parameters\": {\n        \"resource\": \"message\",\n        \"operation\": \"create\",\n        \"channel\": \"#trading-signals\",\n        \"text\": \"={{ $json.summaryMessage || 'Batch analysis completed' }}\",\n        \"attachments\": [\n          {\n            \"color\": \"={{ $json.alertColor || '#00ff00' }}\",\n            \"title\": \"Top Signals\",\n            \"text\": \"={{ $json.alerts ? $json.alerts.map(a => a.emoji + ' ' + a.message).join('\\\\n') : 'No high-value signals found' }}\",\n            \"fields\": {\n              \"values\": [\n                {\n                  \"title\": \"Success Rate\",\n                  \"value\": \"={{ $json.metadata ? $json.metadata.successRate + '%' : 'N/A' }}\",\n                  \"short\": true\n                },\n                {\n                  \"title\": \"Top Score\",\n                  \"value\": \"={{ $json.metadata ? $json.metadata.topScore.toFixed(1) : 'N/A' }}\",\n                  \"short\": true\n                }\n              ]\n            },\n            \"footer\": \"THub V2 Batch Analysis\",\n            \"ts\": \"={{ Math.floor(Date.now() / 1000) }}\"\n          }\n        ],\n        \"otherOptions\": {}\n      },\n      \"id\": \"notify-results\",\n      \"name\": \"Notify Results\",\n      \"type\": \"n8n-nodes-base.slack\",\n      \"typeVersion\": 2.3,\n      \"position\": [1650, 200],\n      \"onError\": \"continueRegularOutput\"\n    },\n    {\n      \"parameters\": {\n        \"respondWith\": \"json\",\n        \"responseBody\": \"={{ { success: true, summary: $json.summary, signalsCreated: $json.summary ? $json.summary.signalsCreated : 0, timestamp: new Date().toISOString() } }}\",\n        \"options\": {\n          \"responseCode\": 200\n        }\n      },\n      \"id\": \"success-response\",\n      \"name\": \"Success Response\",\n      \"type\": \"n8n-nodes-base.respondToWebhook\",\n      \"typeVersion\": 1.1,\n      \"position\": [1450, 400]\n    },\n    {\n      \"parameters\": {\n        \"respondWith\": \"json\",\n        \"responseBody\": \"={{ { error: true, message: 'No symbols provided for analysis', timestamp: new Date().toISOString() } }}\",\n        \"options\": {\n          \"responseCode\": 400\n        }\n      },\n      \"id\": \"error-response\",\n      \"name\": \"Error Response\",\n      \"type\": \"n8n-nodes-base.respondToWebhook\",\n      \"typeVersion\": 1.1,\n      \"position\": [450, 500]\n    }\n  ],\n  \"connections\": {\n    \"Batch Analysis Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Prepare Priority Batches\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Prepare Priority Batches\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Split Batches\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ],\n        [\n          {\n            \"node\": \"Error Response\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Split Batches\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Analyze Batch\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ],\n        [\n          {\n            \"node\": \"Aggregate Results\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Analyze Batch\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Split Batches\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ],\n      \"error\": [\n        [\n          {\n            \"node\": \"Split Batches\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Aggregate Results\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Signals Created?\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Signals Created?\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Format Alerts\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ],\n        [\n          {\n            \"node\": \"Success Response\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Format Alerts\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Notify Results\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Notify Results\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Success Response\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  },\n  \"settings\": {\n    \"executionOrder\": \"v1\",\n    \"saveManualExecutions\": true,\n    \"callerPolicy\": \"workflowsFromSameOwner\",\n    \"executionTimeout\": 300\n  },\n  \"staticData\": null,\n  \"tags\": [\n    {\n      \"createdAt\": \"2025-01-08T04:00:00.000Z\",\n      \"updatedAt\": \"2025-01-08T04:00:00.000Z\",\n      \"id\": \"1\",\n      \"name\": \"THub V2\"\n    },\n    {\n      \"createdAt\": \"2025-01-08T04:00:00.000Z\", \n      \"updatedAt\": \"2025-01-08T04:00:00.000Z\",\n      \"id\": \"3\",\n      \"name\": \"Batch Analysis\"\n    }\n  ],\n  \"triggerCount\": 1,\n  \"updatedAt\": \"2025-01-08T04:00:00.000Z\",\n  \"versionId\": \"1\"\n}